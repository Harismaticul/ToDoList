import { createAsyncThunk, createSlice, PayloadAction } from "@reduxjs/toolkit";
import { RootState, AppThunk, store } from "../../app/store";
//import { fetchToDoItemDetails } from './todolistAPI';
import {
  ToDoDataProp,
  ToDoState,
  IServerToDoData,
} from "../../Types/ToDoItemProp";
import axios from "axios";

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.
// export const fetchToDoItemDetailsAsync = createAsyncThunk(
//   'todolist/fetchToDoItemDetails',
//   async () => {
//     const response = await fetchToDoItemDetails();
//     // The value we return becomes the `fulfilled` action payload
//     return response.todoitems;
//   }
// );

//axios.get("http://localhost:7071/api/item").then(({ data }) => {  dispatch(setArticleDetails(data));

function stateMapper(x: number){
  switch (x) {
    case 0:
      return ToDoState.NOT_STARTED;
    case 1:
      return ToDoState.STARTED;
    case 2:
      return ToDoState.DONE;
    default:
      return ToDoState.NOT_STARTED;
  }
};

export const addNewItem = createAsyncThunk("todoitems/addNewItem", async (newDescription:string) => {
  //const response = await client.get('/fakeApi/posts')
  const response = await axios.post<IServerToDoData>(
    "http://localhost:7071/api/item", {"Description":newDescription}
  );

  return {
    todoitemid: response.data.id.toString(),
    state: stateMapper(response.data.state),
    description: response.data.description,
    created: response.data.createdAt,
    isSelectedForDelete: false,
  };
});

export const removeSelectedItems = createAsyncThunk("todoitems/removeSelectedItems", async () => {
  
  const state = store.getState();

  //const response = await client.get('/fakeApi/posts')
  state.todolist.todoitems.forEach(async (element) => {
    if (element.isSelectedForDelete){
      const response = await axios.delete("http://localhost:7071/api/item/".concat(element.todoitemid)
    )};
  });
  

  // return {
  //   todoitemid: response.data.id.toString(),
  //   state: stateMapper(response.data.state),
  //   description: response.data.description,
  //   created: response.data.createdAt,
  //   isSelectedForDelete: false,
  // };
});

export const fetchItems = createAsyncThunk("todoitems/fetchItems", async () => {
  //const response = await client.get('/fakeApi/posts')
  const response = await axios.get<IServerToDoData[]>(
    "http://localhost:7071/api/item"
  );

  const items = response.data.map((x) => {
    return {
      todoitemid: x.id.toString(),
      state: stateMapper(x.state),
      description: x.description,
      created: x.createdAt,
      isSelectedForDelete: false,
    };
  });

  return { todoitems: items };
});

enum RequestState {
  NotStarted,
  Requested,
  RequestSucceded,
  RequestFailed,
}

export interface appStateType {
  todoitems: ToDoDataProp[];
  status: RequestState;
}

const initialState: appStateType = {
  todoitems: [],
  status: RequestState.NotStarted,
  // error, if properly done
};

export const todolistSlice = createSlice({
  name: "todolist",
  initialState: initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    // DELETE
    // deleteSelectedItems: (state) => {
    //   state.todoitems = state.todoitems.filter((x) => !x.isSelectedForDelete);
    // },
    changeItemSelection: (
      state,
      action: PayloadAction<ChangeItemSelectionPayload>
    ) => {
      for (let i = 0; i < state.todoitems.length; ++i) {
        if (state.todoitems[i].todoitemid === action.payload.itemid) {
          state.todoitems[i].isSelectedForDelete = action.payload.isSelected;
          break;
        }
      }
    },
    getInitialDownload: (state) => {
      state.todoitems = [];
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(fetchItems.pending, (state) => {
        state.status = RequestState.Requested;
      })
      .addCase(fetchItems.fulfilled, (state, action) => {
        state.status = RequestState.RequestSucceded;
        state.todoitems = action.payload.todoitems;
      })
      .addCase(addNewItem.pending, (state) => {
        state.status = RequestState.Requested;
      })
      .addCase(addNewItem.fulfilled, (state, action) => {
        state.status = RequestState.RequestSucceded;
        state.todoitems .push( action.payload);
      })
      ;
  },
});

export const {
  //DELETEdeleteSelectedItems,
  changeItemSelection,
  getInitialDownload,
} = todolistSlice.actions;

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`
export const selectToDoItems = (state: RootState) => state.todolist;

// We can also write thunks by hand, which may contain both sync and async logic.
// Here's an example of conditionally dispatching actions based on current state.
export const incrementIfOdd =
  (amount: number): AppThunk =>
  (dispatch, getState) => {
    //const currentValue = selectCount(getState());
    //if (currentValue % 2 === 1) {
    //  dispatch(incrementByAmount(amount));
    //}
  };

export default todolistSlice.reducer;

export interface ChangeItemSelectionPayload {
  itemid: string;
  isSelected: boolean;
}

export interface CreateNewItemData {
  description: string;
}
